// Тим Бе́рнерс-Ли совместно с Робертом Кайо
// HTTP HyperText Transfer Protocol — протокол передачи гипертекста

// Основным объектом манипуляции в HTTP является ресурс, на который указывает URI в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.
// Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ».
// В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах.

// программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:

// Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);
// Клиенты — конечные потребители услуг сервера (отправка запроса);
// Прокси (посредники) для выполнения транспортных служб.

// Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:

// Стартовая строка (англ. Starting line) — определяет тип сообщения;
// Метод URI HTTP/Версия
// Стартовая строка ответа сервера:
// HTTP/Версия КодСостояния Пояснение

// Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
// Все заголовки разделяются на четыре основных группы:
// General Headers (рус. Общие заголовки) — используются в запросах и ответах.
// Request Headers (рус. Заголовки запроса) — используются только в запросах.
// Response Headers (рус. Заголовки ответа) — используются только в ответах.
// Entity Headers (рус. Заголовки сущности) — сопровождают каждую сущность сообщения. Используются в запросах и ответах.

// Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

// HTTP/1.1
// Современная версия протокола; принята в июне 1999 года[2]. Новым в этой версии был режим «постоянного соединения»: TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать информацию об имени хоста, к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.

// HTTP/2
// 11 февраля 2015 года. В отличие от предыдущих версий, протокол HTTP/2 является бинарным. Среди ключевых особенностей: мультиплексирование запросов (загрузка нескольких элементов параллельно посредством одного TCP-соединения), расстановка приоритетов для запросов, сжатие заголовков, поддержка проактивных push-уведомлений со стороны сервера[3].

// URI - Universal Resource Identifier — универсальный идентификатор ресурса.
// URL - Uniform Resource Locator - Унифицированный указатель ресурса.
// <схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]

// схема - обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
// логин - имя пользователя, используемое для доступа к ресурсу
// пароль - указанного пользователя
// хост - полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста.
// порт - хоста для подключения
// URL-путь - уточняющая информация о месте нахождения ресурса; зависит от протокола.
// параметры - строка запроса с передаваемыми на сервер (методом GET) параметрами. Начинается с символа ?, разделитель &.
// якорь - символом #. Якорем может быть указан заголовок внутри документа или атрибут id элемента. По такой ссылке браузер откроет страницу и переместит окно к указанному элементу.

// Поскольку URI не всегда указывает на то, как получить ресурс, в отличие от URL, а только идентифицирует его, это даёт возможность описывать с ресурсы, которые не могут быть получены через Интернет.

// XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
// На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch.
// XMLHttpRequest имеет два режима работы: синхронный и асинхронный.

const xhr = new XMLHttpRequest();
xhr.open("GET", "https://api.spacexdata.com/v3/capsules"); // method, URI, [async, user, password]

// Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно отсылается запрос только лишь после вызова send.

// Если в методе open третий параметр async установлен на false, запрос выполняется синхронно.
// Многие продвинутые возможности XMLHttpRequest, такие как выполнение запроса на другой домен или установка таймаута, недоступны для синхронных запросов. Также, как вы могли заметить, ни о какой индикации прогресса речь тут не идёт.

// Мы можем использовать свойство xhr.responseType, чтобы указать ожидаемый тип ответа
xhr.responseType = "json";

// setRequestHeader(name, value)
// Устанавливает заголовок запроса с именем name и значением value.

xhr.setRequestHeader("Content-Type", "application/json");
// Если заголовок определён, то его нельзя снять. Повторные вызовы лишь добавляют информацию к заголовку, а не перезаписывают его.

// getResponseHeader(name)
// Возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2).

console.log(xhr.getAllResponseHeaders());

// Cобытия:

// происходит периодически во время загрузки ответа, сообщает о прогрессе.
xhr.onprogress = (event) => {
  // event.loaded - количество загруженных байт
  // event.lengthComputable = равно true, если сервер присылает заголовок Content-Length
  // event.total - количество байт всего (только если lengthComputable равно true)
  console.log(`Загружено: ${event.loaded} ${event.lengthComputable ? `из ${event.total}` : ""}`);
};

// происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой.
xhr.onload = () =>
  console.log(
    `Status: ${xhr.status};
 Body:`,
    xhr.response
  );

// происходит, только когда запрос совсем не получилось выполнить
xhr.onerror = () => console.log(`Ошибка соединения`);

xhr.send(); // Необязательный параметр body содержит тело запроса.
// Если мы передумали делать запрос, можно отменить его вызовом xhr.abort():

console.dir(xhr);

console.log("Runing code...");

console.log([1,2,2,3][0]);
console.log(12[0]);

