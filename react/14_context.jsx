// Context

// Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.

// Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов

// Передача пропсов вниз выглядит избыточной, если в итоге их использует только один компонент. Так же плохо, если компоненту вдруг потребуется больше пропсов сверху, тогда вам придётся добавить их на все промежуточные уровни.
// Один из способов решить эту проблему без контекста — передать вниз сам компонент.

// Этот способ может сделать ваш код чище во многих случаях, уменьшая количество пропсов, которые вы должны передавать через ваше приложение, и давая больше контроля корневым компонентам.

//  Однако, Перемещая больше сложной логики вверх по дереву, вы перегружаете вышестоящие компоненты.

import React from "react";
import ReactDOM from "react-dom";

// const MyContext = React.createContext(defaultValue);

// Создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.

// Аргумент defaultValue используется только в том случае, если для компонента нет подходящего Provider выше в дереве.
// Это может быть полезно для тестирования компонентов в изоляции без необходимости оборачивать их. Обратите внимание: если передать undefined как значение Provider, компоненты, использующие этот контекст, не будут использовать defaultValue.

const Context = React.createContext();
const AContext = React.createContext();

class ThemedButton extends React.Component {
  constructor(props) {
    super(props);
  }
  // static contextType = Context;

  // Все потребители, которые являются потомками Provider, будут повторно рендериться, как только проп value у Provider изменится. Потребитель (включая .contextType и useContext) перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью shouldComponentUpdate
  // Изменения определяются с помощью сравнения нового и старого значения, используя алгоритм, аналогичный Object.is.
  render() {
    console.log(this.context);

    return <input onChange={(e) => this.context.setLeter(e.target.value)} />;
  }
}

ThemedButton.contextType = Context;
// В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.

// Использование нескольких контекстов
// Чтобы последующие рендеры (связанные с контекстом) были быстрыми, React делает каждого потребителя контекста отдельным компонентом в дереве.

function Title() {
  return (
    <AContext.Consumer>
      {(aValue) => (
        <Context.Consumer>
          {(value) => (
            <h1>
              {value.leter}
              {aValue}
            </h1>
          )}
        </Context.Consumer>
      )}
    </AContext.Consumer>
  );
}
// Если два или более значений контекста часто используются вместе, возможно, вам стоит рассмотреть создание отдельного компонента, который будет передавать оба значения дочерним компонентам с помощью паттерна «рендер-пропс».

function Toolbar() {
  return (
    <div>
      <Title />
      <ThemedButton />
    </div>
  );
}

class App extends React.Component {
  constructor(props) {
    super(props);
    // Довольно часто необходимо изменить контекст из компонента, который находится где-то глубоко в дереве компонентов. В этом случае вы можете добавить в контекст функцию, которая позволит потребителям изменить значение этого контекста:
    this.state = {
      leter: "",
      setLeter: (leter) => this.setState({ leter }),
    };
  }

  render() {
    return (
      // Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения
      <Context.Provider value={this.state}>
        <AContext.Provider value="A">
          {/* Принимает проп value, который будет передан во все компоненты, использующие этот контекст и являющиеся потомками этого Provider компонента. Один Provider может быть связан с несколькими компонентами, потребляющими контекст. Так же Provider компоненты могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве */}
          <Toolbar />
        </AContext.Provider>
      </Context.Provider>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));

// <Context.Consumer />
// Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте.

// Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().

// Context.displayName
// Объекту Context можно задать строковое свойство displayName. React DevTools использует это свойство при отображении контекста.

