// state and life cycle
import React from "react";
import ReactDOM from "react-dom";

class Clock extends React.Component {
  constructor(props) {
    // Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.
    super(props);

    // Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.

    this.state = { date: new Date() };
    //  state — это обычные JavaScript-объекты, содержат информацию, которая влияет на то, что увидим после рендера, состояние контролируется и доступно только конкретному компоненту.
  }

  // Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting)
  componentDidMount() {
    // componentDidMount - после того, как компонент отрендерился в DOM
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  // Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов здесь нужно избавлятся от слушателей таймеров и всех побочных ефектов компонента
  componentWillUnmount() {
    // componentWillUnmount - до того, как компонент удалится из DOM.
    clearInterval(this.timerID);
    // В приложениях с множеством компонентов очень важно освобождать используемые системные ресурсы когда компоненты удаляются.
  }

  tick() {
    // this.setState() - планирует обновление внутреннего состояния компонента
    this.setState({
      date: new Date(),
    });
    // Не изменяйте состояние напрямую "this.state.date = new Date()"

    // React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
    // Второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента: this.setState((state, props) => ({ result: state.a + props.b}));

    // Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием.
    // Состояния объединяются поверхностно, поэтому вызов this.setState({a}) оставляет this.state.b нетронутым, но полностью заменяет this.state.a.
  }

  // Метод render будет вызываться каждый раз, когда происходит обновление.
  render() {
    return (
      <div>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(<Clock />, document.getElementById("root"));

// Однонаправленный поток данных

// В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента.

// Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.

// Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов

// Этот процесс называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.

// Жизненный цикл компонента
// Каждый компонент имеет несколько «методов жизненного цикла». Переопределение такого метода позволяет выполнять код на конкретном этапе этого процесса.

// Монтирование____
// При создании экземпляра компонента и его вставке в DOM

// constructor()
// static getDerivedStateFromProps()
// render()
// componentDidMount()

// Обновление_____
// Обновление происходит при изменении пропсов или состояния

// static getDerivedStateFromProps()
// shouldComponentUpdate()
// render()
// getSnapshotBeforeUpdate()
// componentDidUpdate()

// Размонтирование
// Этот метод вызывается при удалении компонента из DOM:
// componentWillUnmount()

// Обработка ошибок
// static getDerivedStateFromError()
// componentDidCatch()

// render() — единственный обязательный метод в классовом компоненте.
// При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов:
// Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null.
// Функция render() должна быть чистой. Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же результат, не взаимодействует напрямую с браузером.

// constructor(props)
// Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
// Конструкторы в React обычно используют для двух целей:
// Инициализация внутреннего состояния через присвоение объекта this.state.
// Привязка обработчиков событий к экземпляру.

// componentDidMount() вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
// Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
// можете сразу вызвать setState()

// componentDidUpdate(prevProps, prevState, snapshot)
// Вызывается сразу после обновления. Не вызывается при первом рендере.
// Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
// В componentDidUpdate() можно вызывать setState(), однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл.
// когда реализован метод жизненного цикла getSnapshotBeforeUpdate(), его результат передаётся componentDidUpdate() в качестве третьего параметра snapshot.

// componentWillUnmount() вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

// shouldComponentUpdate(nextProps, nextState)
// Используйте чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов.
// вызывается когда получает новые пропсы или состояние, перед рендером. 
// В настоящее время, если shouldComponentUpdate() возвращает false, то UNSAFE_componentWillUpdate(), render() и componentDidUpdate() не будут вызваны.
// Этот метод не вызывается при первом рендере или когда используется forceUpdate().

// getDerivedStateFromProps вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
// Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
// Производное состояние приводит к сложному коду и делает ваши компоненты сложными для понимания.

// getSnapshotBeforeUpdate() вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM

// Предохранители
// Предохранители — это React-компоненты, которые перехватывают JavaScript-ошибки в любом месте их дочернего дерева компонентов. Затем логируют эти ошибки и отображают запасной интерфейс вместо «поломанного» дерева компонентов.

// Классовый компонент становится предохранителем, если в нём используются методы жизненного цикла static getDerivedStateFromError() и (или) componentDidCatch(). Обновление состояния в этом методе жизненного цикла позволяет перехватить необработанную JavaScript-ошибку в дереве ниже и отобразить запасной интерфейс.
// Используйте предохранители только для обработки неожиданных исключений, не используйте их для управления потоком исполнения в вашем приложении.
// Предохранители перехватывают ошибки в компонентах ниже по дереву. Предохранители не могут поймать ошибку внутри себя.

// static getDerivedStateFromError(error)
// Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния.

// getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().

// componentDidCatch(error, info)
// Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра:
// error — перехваченная ошибка
// info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка.

// componentDidCatch() вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно использовать для логирования ошибок.

// Устаревшие методы жизненного цикла: 
// UNSAFE_componentWillMount()
// UNSAFE_componentWillReceiveProps()
// UNSAFE_componentWillUpdate()

// component.forceUpdate(callback)
// По умолчанию при изменении состояния компонента или пропсов, происходит повторный рендер. Если ваш метод render() зависит от некоторых других данных, вы можете указать React необходимость в повторном рендере, вызвав forceUpdate()
// Чаще всего, forceUpdate() не используется. Вместо этого используются в render() данные из this.props и this.state.