// Основные хуки
//    useState
//    useEffect
//    useContext

// Дополнительные хуки
//    useReducer
//    useCallback
//    useMemo
//    useRef
//    useImperativeHandle
//    useLayoutEffect
//    useDebugValue

// const [state, setState] = useState(initialState);
// Возвращает значение с состоянием и функцию для его обновления.

// useEffect(didUpdate);
// Принимает функцию, которая содержит императивный код, возможно, с эффектами.
// Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.
// По умолчанию эффекты запускаются после каждого завершённого рендеринга

// const value = useContext(MyContext);
// Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.

// const [state, dispatch] = useReducer(reducer, initialArg, init);
// Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. (Если вы знакомы с Redux, вы уже знаете, как это работает.)
// Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.


const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
// Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам



